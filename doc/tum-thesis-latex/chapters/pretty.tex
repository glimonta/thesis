\chapter{Pretty Printer}\label{chapter:pretty}

In this chapter we will detail the \textit{pretty printing} (translation) that happens in the semantics and allows us to export C code.
To assist us in this translation process we used Sternagel and Thiemann's implementation of Haskell's Show class in Isabelle/HOL~\parencite{Show-AFP}.
In that implementation they implement a type class for ``to-string'' functions as well as instantiations for Isabelle/HOL's standard types.
Moreover they allow for deriving show functions for arbitrary user defined datatypes.
We instantiate this class creating a ``show'' function for each of our defined datatypes incrementally until we can print a program.
The following sections will explain in detail the concrete strings we get as a result of our translation.

\section{Words}\label{section:pretty_words}
The first instantiation of shows we must make is the one for words in order to be able to pretty print values of this type.
For pretty printing a value of the type word we will simply cast that value to an Isabelle/HOL's predefined int type and use the \verb|show| function for it.
As a result our words will be pretty printed as signed integers.

\section{Values}\label{section:pretty_values}

\subsection{Val type}\label{subsection:pretty_val_type}
The type \verb|val| is the first user defined type we provide an instantiation for.
In table~\ref{tab:pretty_val} we find the equivalence between the abstract syntax for the \verb|val| type and the string representation.
Note that $w$, $base$ and $ofs$ range over words, nats and integers, therefore their show functions will be used to obtain their string representation e.g.\ the string representation for $\mathtt{I}\ 42$ would be $"42"$, the string representation for $\mathtt{A}\ (4,\ 2)$ would be $"4[2]"$.
A list of values is showed by showing each value in a list notation, i.e.\ $[vname\ =\ value, \dots, vname_n\ =\ value_n]$.

We will enclose parameters in between brackets ($"<\ >"$ ) to indicate that what's enclosed in them is a string representation which results from applying a shows function on the parameter and will continue to use this notation throughout the rest of the document.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|NullVal| & null \\
  \verb|I| $w$ & $<w>$ \\
  \verb|A| $(base,\ ofs)$ & <$base$>[<$ofs$>] \\
  \hline
\end{tabular}

\caption{Translation of val type}
\label{tab:pretty_val}
\end{table}

\subsection{Val option type}\label{subsection:pretty_val_option_type}

Now that we know how to represent a \verb|val| type in the form of a string we must also know how to represent a \verb|val option|.
A \verb|val option| holds the semantic meaning of an initialized and an uninitialized value.
Table~\ref{tab:pretty_val_option} shows the equivalence between the abstract syntax and the string representation.
Here an initialized value will just be the string resulting from showing that value, whereas an uninitialized value's string representation will be a $''?''$ to represent its value is not yet known.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|Some| v & <$v$> \\
  \verb|None| & ? \\
  \hline
\end{tabular}

\caption{Translation of val option type}
\label{tab:pretty_val_option}
\end{table}


\subsection{Valuations}\label{subsection:pretty_valuations}

It must also be possible to have a string representation of a valuation.
In order to represent a valuation we need an extra parameter, namely a list of variable names, this list will have the names of the variables for which we want to print their value in the valuation.
The valuation will be printed in the following format:
\begin{equation*}
[<vname_0> = <value_0>, <vname_1> = <value_1>, \dots, <vname_n> = <value_n>]
\end{equation*}

For instance, if we take the valuation $[foo \mapsto \mathtt{Some}(\mathtt{I}\ 15), bar \mapsto None, baz \mapsto \mathtt{Some}(\mathtt{A}(1,9))]$ and the list of variables $[foo, bar, baz]$ then we would get the following as a string representation for the valuation:

\begin{equation*}
[foo\ =\ 15,\ bar\ =\ ?,\ baz\ =\ 1[9]]
\end{equation*}


\section{Memory}\label{section:pretty_memory}

In order to show the memory we must first know how to show a string representation of the content of a block and a string representation of the whole block.

When we access a block in the memory we can get either the content of the block or a \verb|None| value indicating a free block of memory.
Table~\ref{tab:pretty_block_content} shows the string representations for this, notice that in the case of a \verb|None| value we print the \verb|free| string enclosed in brackets, being the brackets part of the string representation and posing an exception to the notation described previously.
If the content of the block is a list of values then we show the list of values.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|Some| content & <$content$> \\
  \verb|None| & <free> \\
  \hline
\end{tabular}

\caption{Translation of Block content}
\label{tab:pretty_block_content}
\end{table}

A complete block will be printed as follows:
\begin{equation*}
<base>\ :\ <block_content> 
\end{equation*}

where $base$ is the first component of an address value that indexes the blocks and $block_content$ is the string representation of the content of block number $base$.

Finally, in order to show the whole memory, we only need to show each block existing in the memory.
For instance, the string representation of memory state:
\begin{equation*}
[\mathtt{Some}\ [\mathtt{I}\ 13,\ \mathtt{None}],\ None,\ \mathtt{Some}\ [\mathtt{A}(2,3),\ None, \mathtt{I}\ 56]]
\end{equation*}
would be:
\begin{align*}
0\ &:\ [13,\ ?] \\
1\ &:\ <free> \\
2\ &:\ [2[3],\ ?,\ 56]
\end{align*}


\section{Expressions}
In order to print expressions we must be able to print unary and binary operations.
We must also be able to print casts from and to pointers.
We use C's \verb|intptr_t| which is big enough to hold the value of an integer as well as the value of a pointer, we do so due to the fact that we only have integer values in our language and we separate address values from them in the semantics level.

At the C level we must be able to tell the compiler when some value is meant to be an address and cast it as such.
We allow this casting between addresses and integers during the translation process because we know for sure when a value should be interpreted as an address and when it should be interpreted as an integer, whereas C does not.

\paragraph{Unary and binary operations}
When pretty printing binary operations we will use parenthesis around every expression pretty printed, this will naturally generate more parenthesis than needed but we are willing to make this choice to ensure the evaluation order remains the same as intended and we do not get different evaluation orders because of operator precedence.

A binary operator is pretty printed in an infix way:
\begin{equation*}
(<operand_1> <operator> <operand_2>)
\end{equation*}

Examples of this are shown in table~\ref{tab:pretty_bin_op}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|Plus| (\verb|Const| $11$) (\verb|Const| $11$) & ($11\ +\ 11$) \\
  \verb|Subst| (\verb|Const| $9$) (\verb|Const| $5$) & ($9\ -\ 5$) \\
  \verb|Mult| (\verb|Const| $2$) (\verb|Const| $3$) & ($2\ *\ 3$) \\
  \hline
\end{tabular}

\caption{Examples of binary operators' pretty printing}
\label{tab:pretty_bin_op}
\end{table}

An unary operator is pretty printed in a prefix way:
\begin{equation*}
<operator> (<operand>)
\end{equation*}

Notice we enclose the operand in parenthesis in order to guarantee correct precedence in the operations.

Examples of this are shown in table~\ref{tab:pretty_un_op}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|Minus| (\verb|Const| $11$) & $-\ (11)$ \\
  \verb|Not| (\verb|Const| $0$) & $!\ (0)$ \\
  \hline
\end{tabular}

\caption{Examples of unary operators' pretty printing}
\label{tab:pretty_un_op}
\end{table}

\paragraph{Casts}
Since the values we are working with must be interpreted in C sometimes as integers and sometimes as pointers we must be able to pretty print an explicit cast between those two types in our generated program.
We include casts to pointers when dealing with referencing, dereferencing and indexing.
We will want to cast to integers in the case of a memory allocation.
A memory allocation returns a pointer but in order to assign that to a variable we must cast it to an integer, due to the fact that all our variables are declared with the \verb|intptr_t| type and not \verb|intptr_t *|, we can do this and we know that when working with addresses these will be interpreted the right way since we will add a cast back to pointer.


A cast to an address value will be pretty printed in the following way:
\begin{equation*}
(\mathtt{intptr\_t}\ *) <expression>
\end{equation*}

A cast to an integer value will be pretty printed in the following way:
\begin{equation*}
(\mathtt{intptr\_t}) <expression>
\end{equation*}

In table~\ref{tab:pretty_casts} we can find examples of the pretty printing of casts.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|New| (\verb|Const| $9$) & $(\mathtt{intptr\_t})\ \mathtt{malloc}\ (\mathtt{sizeof}(\mathtt{intptr\_t}) * ($9$))$ \\
  \verb|Deref| (\verb|V| $foo$) & $*((\mathtt{intptr\_t}\ *)\ $x$)$ \\
  \hline
\end{tabular}

\caption{Examples of casts' pretty printing}
\label{tab:pretty_casts}
\end{table}


\paragraph{Expressions}
Finally we present in table~\ref{tab:pretty_expressions} the string representation for each of the expressions.
We use simple expressions as operands such as variables or constant values for simplicity, but the expressions can be conformed by more complicated expressions.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|Const| $42$ & $42$ \\
  \verb|Null| & (\verb|intptr_t| *) $0$ \\
  \verb|V| $x$ & $x$ \\
  \verb|Plus| $(\mathtt{Const}\ 2)\ (\mathtt{Const}5)$ & $(2\ +\ 5)$ \\
  \verb|Subst| $(\mathtt{Const}\ 9\ (\mathtt{Const}5)$ & $(9\ -\ 5)$ \\
  \verb|Minus| $(\mathtt{Const}\ 9)$ & ($-9$) \\
  \verb|Div| $(\mathtt{Const}\ 8)\ (\mathtt{Const}\ 4)$ & $(8\ /\ 4)$ \\
  \verb|Mod| $(\mathtt{Const}\ 8)\ (\mathtt{Const}\ 4)$ & $(8\ \%\ 4)$ \\
  \verb|Mult| $(\mathtt{Const}\ 9)\ (\mathtt{Const}\ 3)$ & $(9\ *\ 3)$ \\
  \verb|Less| $(\mathtt{Const}\ 7)\ (\mathtt{Const}\ 9)$ & $(7\ <\ 9)$ \\
  \verb|Not| $(\mathtt{Const}\ 0)$ & $!\ (0)$ \\
  \verb|And| $(\mathtt{Const}\ 1)\ (\mathtt{Const}\ 1)$ & $(1\ \&\&\ 1)$ \\
  \verb|Or| $(\mathtt{Const}\ 1)\ (\mathtt{Const}\ 0)$ & $(1\ || 0)$ \\
  \verb|Eq| $(\mathtt{Const}\ 6)\ (\mathtt{Const}\ 4)$ & $(6\ == 4)$ \\
  \verb|New| $(\mathtt{Const}\ 9)$ & $(\mathtt{intptr\_t})\ \mathtt{malloc}\ (\mathtt{sizeof}(\mathtt{intptr\_t}) * ($9$))$ \\
  \verb|Deref| $(\mathtt{V}\ foo)$ & $*((\mathtt{intptr\_t}\ *)\ foo)$ \\
  \verb|Ref| $(\mathtt{V}\ foo)$ & $((\mathtt{intptr\_t}\ *)\ \&(foo))$ \\
  \verb|Index| $(\mathtt{V}\ bar)\ (\mathtt{Const}\ 3)$ & $((\mathtt{intptr\_t}\ *)\ bar[3])$ \\
  \verb|Derefl| $(\mathtt{V}\ foo)$ & $(*((\mathtt{intptr\_t}\ *)\ foo))$ \\
  \verb|Indexl| $(\mathtt{V}\ bar)\ (\mathtt{Const}\ 3)$ & $((\mathtt{intptr\_t}\ *)\ bar[3])$ \\
  \hline
\end{tabular}

\caption{Examples of Expressions' pretty printing}
\label{tab:pretty_expressions}
\end{table}


\section{Commands}
First of all we need a way of printing indented commands to facilitate the generated code.
We define two auxiliary abbreviatons that will pretty print white spaces for intentation at the beginning of a construct.
The reason why two abbreviations are defined is because one of them will also pretty print a $";"$ terminator after the construct whereas the other will not.

We also define a way of pretty printing function calls.
Function calls will be pretty printed according to the following format:
\begin{equation*}
<function\_name>\ ([<argument_0, argument_1, \dots, <argument_n>])
\end{equation*}

where the brackets ($[]$) indicate that the arguments are optional.

Finally the commands in Chloe are pretty printed as the examples in table~\ref{tab:pretty_commands} shows.
We use $''$ to indicate an empty string.
The correct level of indentation is indicated in the function parameters that are responsible for the pretty printing, we will omit those here and instead list where the indentation will increase.
Indentation will increase inside a block, i.e.\ the branches of a conditional, the body of a loop.

\begin{table}[h!]
\centering
\begin{tabular}{|c|l|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|SKIP| & $''$ \\
  \hline
  \verb|Assignl| $(\mathtt{Derefl}\ foo)\ (\mathtt{Const}\ 4)$ & $*((\mathtt{intptr\_t}\ *)\ foo)\ =\ 4;$ \\
  \hline
  \verb|Assign| $(\mathtt{V}\ foo)\ (\mathtt{Const}\ 4)$ & $foo\ =\ 4;$ \\
  \hline
  \verb|Seq| $c_1\ c_2$ & $<c_1> <c_2>$ \\
  \hline
  $\mathtt{If}\ (\mathtt{V}\ b)$                              & $\mathtt{if}\ (b)\ \{$\\
  $(\mathtt{Assign}\ (\mathtt{V}\ foo) (\mathtt{Const}\ 4))$  & $\ \ foo\ =\ 4;$ \\
  $\mathtt{SKIP}$                                             & $\}$ \\
  \hline
  $\mathtt{If}\ (\mathtt{V}\ b)$                              & $\mathtt{if}\ (b)\ \{$\\
  $(\mathtt{Assign}\ (\mathtt{V}\ foo) (\mathtt{Const}\ 4))$  & $\ \ foo\ =\ 4;$ \\
  $(\mathtt{Assign}\ (\mathtt{V}\ bar) (\mathtt{Const}\ 3))$  & $\}\ else\ \{$ \\
                                                              & $\ \ bar\ =\ 3;$ \\
                                                              & $\}$ \\
  \hline
  $\mathtt{While}\ (\mathtt{V}\ b)$                           & $\mathtt{while}\ (b)\ \{$\\
  $(\mathtt{Assign}\ (\mathtt{V}\ foo) (\mathtt{Const}\ 4))$  & $\ \ foo\ =\ 4;$ \\
                                                              & $\}$ \\
  \hline
  \verb|Free| $(\mathtt{Derefl}\ foo)$ & $\mathtt{free}\ (\&\ (*((\mathtt{intptr\_t}\ *)\ foo));$ \\
  \hline
  \verb|Return| $(\mathtt{V}\ foo)$ & $\mathtt{return}\ (foo));$ \\
  \hline
  \verb|Returnv| & $\mathtt{return};$ \\
  \hline
  \verb|Callfunl| $(\mathtt{Derefl}\ foo)\ bar\ [\mathtt{V}\ baz,\mathtt{Const}\ 4]$ & $*((\mathtt{intptr\_t}\ *)\ foo)\ =\ bar(baz,\ 4);$ \\
  \hline
  \verb|Callfunl| $(\mathtt{V}\ foo)\ bar\ [\mathtt{Const}\ 65]$ & $foo =\ bar(65);$ \\
  \hline
  \verb|Callfunl| $bar\ []$ & $bar();$ \\
  \hline
\end{tabular}

\caption{Examples of Comands' pretty printing}
\label{tab:pretty_commands}
\end{table}


\section{Function declarations}

Now we must define how declarations are pretty printed.
In order to do so, we will pretty print a function definition according to the following string format:
\begin{equation*}
\begin{split}
&\mathtt{intptr\_t} \ <function\_name>(\mathtt{intptr\_t}\ <arg\_name_0>,\ \dots,\ \mathtt{intptr\_t}\ <arg\_name_n)\ \{ \\
&\ \ \mathtt{intptr\_t}\ <local\_var_0> \\
&\vdots \\
&\ \ \mathtt{intptr\_t}\ <local\_var_n> \\
&<body> \\
&\} \\
\end{split}
\end{equation*}

The return, argument and local variable's type is \verb|intptr_t| since, as mentioned previously, we only have one type in our translation process and we cast to and from pointers when necessary.

An example of a function declaration translation for a factorial function is available in table~\ref{tab:pretty_function_fact}.
In this example we avoid the use of $''\ ''$ for string representations in Isabelle and just write the string without the quotation marks.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
  \hline
  \textbf{Abstract syntax} & \textbf{String representation} \\ [0.5ex]
  \hline \hline
  \verb|definition factorial_decl| $::$ \verb|fun_decl|  & \verb|intptr_t fact(intptr_t n) {| \\
  \verb|where "factorial_decl| $\equiv$                  & \verb|  intptr_t r;| \\
  \verb|  ( fun_decl.name = fact,|                       & \verb|  intptr_t i;| \\
  \verb|    fun_decl.params = [n],|                      & \verb|  r = (1);| \\
  \verb|    fun_decl.locals = [r, i],|                   & \verb|  i = (1);| \\
  \verb|    fun_decl.body =|                             & \verb|  while ((i) < ((n) + (1))) {| \\
  \verb|      r ::= (Const 1);;|                         & \verb|    r = ((r) * (i));| \\
  \verb|      i ::= (Const 1);;|                         & \verb|    i = ((i) + (1));| \\
  \verb|      (WHILE|                                    & \verb|  }| \\
  \verb|         (Less (V i) (Plus (V n) (Const 1)))|    & \verb|  return(r);| \\
  \verb|      DO|                                        & \verb|}| \\
  \verb|        (r ::= (Mult (V r) (V i));;|             & \\
  \verb|        i ::= (Plus (V i) (Const 1)))|           & \\
  \verb|      );;|                                       & \\
  \verb|    RETURN (V r)|                                & \\
  \verb|  )"|                                            & \\
  \hline
\end{tabular}

\caption{Pretty printing of a factorial function declaration}
\label{tab:pretty_function_fact}
\end{table}


\section{States}
\subsection{Return locations}
\section{Programs}
\section{Exporting C code}
\subsection{Architecture checks}