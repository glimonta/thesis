\chapter{Syntax and Semantics}\label{chapter:semantics}

\section{Isabelle}\label{section:isabelle}

Why is Isabelle chosen to use in this work instead of some other tool.
IsabelleHOL, Isabelle's code generation.
Maybe this should be moved to the theoretical background.

\section{Expressions}\label{section:expressions}

Our imperative language is called Chloe and it represents a subset of the C language.
We will now proceed to discuss more in detail the syntax and semantics of the expressions in Chloe.

\subsection{Syntax}\label{subsection:syntax_expressions}

Here we proceed to describe the \textbf{abstract syntax} for the expressions of the Chloe language.

\begin{figure}
  \begin{lstlisting}[frame=single]
  type_synonym vname = string

  datatype exp = Const int
               | Null
               | V      vname
               | Plus  exp exp
               | Subst exp exp
               | Minus exp
               | Div   exp exp
               | Mod   exp exp
               | Mult  exp exp
               | Less  exp exp
               | Not   exp
               | And   exp exp
               | Or    exp exp
               | Eq    exp exp
               | New   exp
               | Deref exp
               | Ref   lexp
               | Index exp exp
  and
  datatype lexp = Deref exp
                | Indexl exp exp
  \end{lstlisting}

  \caption{Chloe expressions}
  \label{fig:chloe_expressions}
\end{figure}

In figure~\ref{fig:chloe_expressions} we can find the datatype created in Isabelle for the expressions, where \verb|int| is the predefined type for integers and \verb|vname| stands for variable name.

We define two new datatypes, one for expressions and one for left-hand-side expressions.
It is important to differentiate between these two in the case where we are dealing with pointer expressions.
For instance, let's take the following C expressions:

\begin{lstlisting}[language=C, frame=single]
foo = *bar;
*baz = 1;
\end{lstlisting}

In the first expression \verb|*bar| is on the right-hand-side, in this case we want \verb|*bar| to yield a value we can then assign to \verb|foo|.
On the other hand, in the second expression \verb|*baz| is on the left-hand-side, in this case we want \verb|*baz| to yield an address to which we can assign the value \verb|1|.

This also occurs with array indexing.
In order to correctly model the semantics for the Chloe expressions it is necessary to have this distinction between left-hand-side expressions and right-hand-side expressions.
In future sections we will proceed to refer to right-hand side expressions as simply expressions and we will use LHS instead of left-hand-side when referring to left-hand-side expressions.

Chloe supports constant expressions, null pointer expression, variables as well as the following operation over expressions: addition, substraction, unary minus, division, modulo, multiplication, less than, not, and, or, equality.
We also have a \verb|New| expression which is the equivalent of a \verb|malloc| call in C.
We have dereferencing, referencing and array subscripting, these are in C the \verb|*|, \verb|&| and \verb|[]| operators, respectively.
Finally as LHS expressions we have dereferencing and array subscripting.

\subsubsection{Types}

In the Chloe language we have two types, namely integers and addresses.
We differentiate between values of type integer and addresses in order to correctly define our semantics.
Next, we will proceed to present the details of the two types in the Chloe language.

\paragraph{Integers}

We define the following type synonyms in Isabelle:

\begin{lstlisting}[frame=single]
type_synonym int_width = 64
type_synonym int_val = int_width word
\end{lstlisting}


The term \verb|int_width| refers to the width of the integer value.
In this case we assume a value of 64 since we are working with a 64 bit architecture.
This parameter indicates the semantics to assume we are working with a 64 bit architecture where the upper and lower bounds for an integer are defined in figure~\ref{fig:int_bounds}.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  abbreviation INT_MIN :: int where INT_MIN $\equiv$ - (2^(int_width - 1))
  abbreviation INT_MAX :: int where INT_MAX $\equiv$  ((2^(int_width - 1)) - 1)
  \end{lstlisting}

  \caption{Integer lower and upper bounds}
  \label{fig:int_bounds}
\end{figure}

When working with a different architecture this parameter can be changed in order to comply with the architechture's requierements.

Also our integers are defined as words of length \verb|int_width| (in this case \verb|64|).
Since we are not using the Isabelle's predefined \verb|int| type, in order to work with words and to support code generation for them we use the Native Word entry in the Archive of Formal Proofs.~\parencite{Native_Word-AFP}.

From now on we will mostly refer to the 64 length words we use to represent integers in our language just as integers.
Note that, unless explicitly stated so in the text, for simplicity we will use the word `integer' to refer to a 64 length word instead of Isabelle's predefined \verb|int| type.

\paragraph{Addresses}

We define the following \verb|datatype| in Isabelle to represent addresses:

\begin{lstlisting}[frame=single, mathescape=true]
datatype addr = nat $\times$ int
\end{lstlisting}

An address will then be a pair conformed by a natural number and an integer (which is an Isabelle predefined \verb|int|), these represent a \verb|(block_id, offset)| pair.
In the following section we will proceed to explain the layout of the memory.

\subsubsection{Values} The values for any expression are defined as follows:

\begin{lstlisting}[frame=single, mathescape=true]
datatype val = NullVal | I $int\_val$ | A $addr$
\end{lstlisting}

where \verb|NullVal| corresponds to the null pointer expression, \verb|I| $int\_val$ corresponds to an integer value, and \verb|A| $addr$ corresponds to an address value.
When evaluating an expression we can obtain any of these three values.

\subsubsection{Memory}

We model dynamic memory in the following way:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym mem = val option list option list
\end{lstlisting}

The memory is represented by a list of allocated blocks, and each of these blocks is conformed by a list of cells with the values in memory.
For every block there's two possibilities: an allocated block or an unallocated block, this is modeled by the use of the \verb|option| type, where \verb|Some| $l$ (where $l$ is of type \verb|val option list|) denotes an allocated block and \verb|None| an unallocated one.
Every block is conformed by a list of cells that contain the values in memory.
Each cell can have different values depending on whether it is uninitialized or it holds a value.
An uninitialized cell in memory is represented by the value \verb|None|.
Whereas a cell holding a value is represented by the value \verb|Some| $v$, where $v$ is of type \verb|val|.

There are four main operations that can manage the memory, these are \verb|new_block|, \verb|free|, \verb|load| and \verb|store| and these are specified in figure ~\ref{fig:mem_operations}.
Each of these operations can fail, therefore their return type is $\tau\ \verb|option|$.
The values of that type are either \verb|None| when the operation fails or $\verb|Some|(v)$ where $v$ is of type $\tau$.

The functionalities of the memory management operations are the following:

\begin{itemize}
  \item{\verb|new_block| is the function that allocates a new block of dynamic memory of a given size.
  This function will fail in the case a size less or equal than zero is given, it can also fail if a value of a different type than an integer is given.
  Upon successful execution the function will yield the beginning address of the new block along with the modified memory.}
  \item{\verb|free| is the function that deallocates a block from the dynamic memory.
  This function will fail in the case where the given address is not a valid one in memory.
  Upon successful execution the function will yield a new state that includes the updated memory.}
  \item{\verb|load| is the function that given an address retrieves a value stored in the memory cell denoted by the given address.
  This function will fail in the case where the given address is not a valid one in memory.
  Upon successful execution the function will yield the value stored in memory.}
  \item{\verb|store| is the function that given an address stores a value in the memory cell denoted by the given address.
  This function will fail in the case where the given address is not a valid one in memory.
  Upon successful execution the function will yield a new state that includes the updated memory.}
\end{itemize}

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  new_block :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  free      :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  load      :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  store     :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  \end{lstlisting}

  \caption{Memory Management operations}
  \label{fig:mem_operations}
\end{figure}

It is important to note that the only reasons why the memory allocation can fail are the ones described above.
Since we assume the memory to be unlimited, there will not be a case where a \verb|new| call fails due to a lack of memory.


Also one of the types used in figure ~\ref{fig:mem_operations}, namely \verb|visible_state|, we have not yet talked about, it will be discussed in further detail in section~\ref{paragraph:visible_state}.

This memory model is inspired in the work of Blazy and Leroy~\parencite{compcert}, it is a simpler model ajusted to satisfy our needs.


\subsection{Semantics}\label{subsection:semantics_expressions}

The semantics of an expression is its value.
For expressions such as $2 + 2$ is trivial to know the value is $4$.
On the other hand when we have expressions with variables, such as $foo + 42$, then we depend on the value of the variable.
Therefore we need to know the values of a variable, these values are stored in the program state.

The program state is a bit more complicated than what we are about to present.
Section~\ref{section:states} is dedicated exclusively to discuss states but we will proceed to clarify in this section the part of the state needed for the expressions' semantics.

\paragraph{Valuations}\label{paragraph:valuation}

We define the type for a valuation as follows:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym valuation = vname $\Rightarrow$ val option option
\end{lstlisting}

A valuation is a function that maps a variable name to a value.
The return type is \verb|val option option| to model the following states of a variable's value: undefined, uninitialized and holding a value.
Therefore, given a variable name, this function can yield one of the following three results:

\begin{itemize}
  \item{\verb|None|, which represents a variable that is undefined.}
  \item{\verb|Some None|, which represents a variable that is defined but uninitialized.}
  \item{\verb|Some| $v$, which represents a defined initialized variable that holds the value $v$.}
\end{itemize}

\paragraph{Visible States}\label{paragraph:visible_state}

A visible state is the state that is visible at any point of a program that is not a function call or a function return.
The defined type for it is as follows:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym visible_state = valuation $\times$ valuation $\times$ mem
\end{lstlisting}

A visible state is a tuple conformed by a valuation function for the local variables, a valuation function for the global variables and the dynamic memory of the program.


Now we can proceed to introduce the semantics for the expressions in Chloe.
As we said before the semantics of an expression is its value, therefore we have defined two evaluation functions, one that computes the value of an expression and one that computes the value of a LHS expression.
These functions defined as follows:

\begin{lstlisting}[frame=single, mathescape=true]
eval   :: exp $\Rightarrow$ visible_state $\Rightarrow$ (val $\times$ visible_state) option
eval_l :: lexp $\Rightarrow$ visible_state $\Rightarrow$ (addr $\times$ visible_state) option
\end{lstlisting}

Where \verb|eval|, given an expression and a visible state, will yield the value of that expression and the visible state resulting after evaluation of that expression.
\verb|eval_l|, given a LHS expression and a visible state, will yield the value of that expression (which must be an address) and the state resulting after the evaluation of the LHS expression.
Notice that the resulting type for these evaluation functions are an \verb|option| type.
This is because these functions can fail, a failure can happen anywhere in the evaluation of the expression and if a failure is found then it will propagate until the whole expression evaluation returns a \verb|None| value indicating an error in evaluation.
Expression evaluation might fail for several reasons which include, but are not limited to, variable undefinedness, an operation failing because it has some illegal operand, trying to access an invalid part of the memory, overflow, among others.
Therefore if there's an error early in the expression evaluation semantics, it will be detected and propagated as a \verb|None| value which indicates an error state.


The \verb|eval| and \verb|eval_l| functions depend on several other defined functions in order to properly compute the values of expressions.
A definition of all the auxiliary functions for \verb|eval| and \verb|eval_l| is given in figure~\ref{fig:aux_fun_eval}.
Except for \verb|div_towards_zero| and \verb|mod_towards_zero|, each of these operations can fail, therefore their return type is $\tau$ \verb|option|.
The values of that type are either \verb|None| when the operation fails or $\verb|Some|(v)$ where $v$ is of type $\tau$.

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  detect_overflow  :: int $\Rightarrow$ val option
  read_var         :: vname $\Rightarrow$ visible_state $\Rightarrow$ val option
  plus_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  subst_val        :: val $\Rightarrow$ val $\Rightarrow$ val option
  minus_val        :: val $\Rightarrow$ val option
  div_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  div_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mod_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  mod_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mult_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  less_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  not_val          :: val $\Rightarrow$ val option
  to_bool          :: val $\Rightarrow$ bool option
  eq_val           :: val $\Rightarrow$ val $\Rightarrow$ val option
  new_block        :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  load             :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  \end{lstlisting}

  \caption{Auxiliary functions for eval and eval\_l}
  \label{fig:aux_fun_eval}
\end{figure}

The functionalities of the auxiliary functions are the following:

\verb|detect_overflow| is the function that detects integer overflow.
It takes an Isabelle predefined integer value as a parameter and checks for overflow with the bounds described in figure~\ref{fig:int_bounds}.
This function will fail whenever overflow is detected.
Upon sucessful execution the function will yield the value correspoding to the given integer parameter.

\verb|read_var| is the function that computes the value of a variable.
This function will fail whenever the variable name given as a parameter corresponds to an undefined variable.
Upon successful execution the function will yield the value of the variable.
In order to compute the value of said variable this function checks the local valuation in the visible state and proceeds to yield the value of the variable if it is defined there.
In the case where the variable is not defined in the local scope, the function will proceed to check the global scope and yield the value of the variable.

\verb|plus_val| is the function that computes the value of an addition between two values.
This function will fail whenever overflow is detected or when anything different than two integers or an address and an integer (in that specific order) are given as parameters to the function.
Upon successful execution with two integer values the function will yield an integer value corresponding to the addition of those operands.
Upon successful execution with an address and an integer the function will yield an address value corresponding to adding the integer offset to the original address value.

\verb|subst_val| is the function that computes the value of a substraction between two values.
This function will fail whenever overflow is detected or when anything different than two integers or an address and an integer (in that specific order) are given as parameters to the function.
Upon successful execution with two integer values the function will yield an integer value corresponding to the substraction of those operands.
Upon successful execution with an address and an integer the function will yield an address value corresponding to substracting the integer offset to the original address value.

\verb|minus_val| is the function that computes the value of the unary minus operation over a value.
This function will fail whenever overflow is detected or a value different from an integer is given as a parameter.
Upon successful execution the function will yield an integer value corresponding to the result of negating the value given as a parameter.

\verb|div_towards_zero| is the function that performs integer division with truncation towards zero.

\verb|div_val| is the function that computes the value of division between two values.
This function will fail whenever either overflow or division by zero are detected or when the parameters given to the function are different from integers.
Upon successful execution the function will yield an integer value corresponding to the result of performing integer division on the function operands.

\verb|mod_towards_zero| is the function that performs the modulo operation with truncation towards zero.

\verb|mod_val| is the function that computes the value of performing the modulo operation between two values.
This function will fail whenever either overflow or modulo by zero are detected or when the parameters given to the function are different from integers.
Upon successful execution the function will yield an integer value corresponding to the result of performing integer modulo on the function operands.

\verb|mult_val| is the function that computes the value of a multiplication between two values.
This function will fail whenever overflow is detected or when anything different from integers are given as parameters to the function.
Upon successful execution the function will yield an integer value corresponding to the multiplication of the function operands.

\verb|less_val| is the function that computes the value of performing the less than operation between two values.
This function will fail whenever anything different from integers are given as parameters to the function.
Upon successful execution the function will yield an integer value of \verb|I| $1$ when the first operand is smaller than the second one, and an integer value of \verb|I| $0$ otherwise.

\verb|not_val| is the function that computes the value of performing logical negation over a value.
This function will fail whenever a parameter different from an integer is given.
Upon successful execution the function will yield an integer value of \verb|I| $1$ when the operand is an integer of value \verb|I| $0$, and an integer value of \verb|I| $0$ when the given operand is any integer value different from \verb|I| $0$.

\verb|to_bool| is a function that yields an Isabelle predefined boolean given a value.
This function is used to compute short-circuit evaluation on the \verb|And| and \verb|Or| operations.
This function will fail whenever the parameter is anything different from an integer.
Upon successful execution the function will yield \verb|False| when the given parameter has a value equal to \verb|I| $0$, it will yield \verb|True| otherwise.

\verb|eq_val| is the function that computes the value of equality comparison between to values.
This function will fail whenever anything different than two integers or two addresses are given as parameters to the function.
Upon successful execution with two integer values the function will yield an integer value of \verb|I| $1$ if both operands were equal and an integer value of \verb|I| $0$ otherwise.
Upon successful execution with two address values the function will yield an integer value of \verb|I| $1$ if both addresses were equal and an integer value of \verb|I| $0$ otherwise.
Two addresses are regarded to as equal whenever both components of the address tuple are equal.

\verb|new_block| and \verb|load| are the functions explained earlier in section~\ref{subsection:syntax_expressions} that allocate a new block of memory and load a value of memory, respectively.


\section{Commands}\label{section:commands}

In this next section we will discuss in detail the syntax and semantics of Chloe's commands as well as functions and programs written in the language and we will discuss some restrictions.

\subsection{Syntax}\label{subsection:syntax_commands}

Chloe contains the following constructs: assignments, sequential composition, conditionals, while loops, SKIP which is equivalent to a noop because it does nothing (we use it to be able to express other syntactic constructs such as a contitional without an \verb|ELSE| branch), deallocation of memory, return statements and functions.
The expressions are the ones described in the previous section (~\ref{section:expressions}).

Here we proceed to describe the \textit{abstract syntax} for the commands of the Chloe language.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  type_synonym fname = string

  datatype
    com = SKIP
        | Assignl lexp exp
        | Assign  vname exp
        | Seq     com  com
        | If      exp com com
        | While   exp com
        | Free    lexp
        | Return exp
        | Returnv
        | Callfunl lexp fname "exp list"
        | Callfun vname fname "exp list"
        | Callfunv fname "exp list"
  \end{lstlisting}

  \caption{Chloe commands}
  \label{fig:chloe_commands}
\end{figure}

In figure~\ref{fig:chloe_commands} we can find the definition of the datatype created in Isabelle for the commands, where \verb|lexp| and \verb|exp| stand for expressions described in the previous sections (~\ref{section:expressions}), \verb|vname| stands for variable names and \verb|fname| stands for the function names.

For assignment commands we define two different commands, one of them allows assignment to a variable, whereas the other one allows assignment to an address location in memory.
We need these two commands since our domain for addresses and integer values is disjoint, therefore an address cannot represent an integer value and viceversa.

We also have two return commands, one of them is for returning from functions with a return value, whereas the other one is for returning from a procedure which has a void return value.

Finally we have three different statements for function calling.
One of them (\verb|Callfunv|) is for functions without a return value.
The other two depend on the return location of the function, if the return location is a variable we use the \verb|Callfun| command and if the return location is a cell in memory we use the \verb|Callfunl| command.

In Isabelle we have defined a concrete infix syntax as well, which facilitates writing and reading commands in Chloe.
In table~\ref{tab:concrete_syntax} we introduce the concrete syntax supposing we have $x$ that ranges over variable names, $a$ that ranges over expressions, $c$, $c_{1}$ and $c_{2}$ that range over commands, $y$ that ranges over the LHS expressions and $f$ that ranges over function names.
We will continue to use the concrete syntax throughout the rest of this work to make it more readable.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{Concrete syntax} \\ [0.5ex]
  \hline \hline
  \verb|Assignl| $y$ $a$ & $y$ \verb|::==| $a$ \\
  \verb|Assign| $x$ $a$ & $x$ \verb|::=| $a$ \\
  \verb|If| $a\ c_{1}\ c_{2}$ & \verb|IF| $a$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ \\
  \verb|While a| $c$ & \verb|WHILE| $a$ \verb|DO| $c$ \\
  \verb|Free| $y$ & \verb|FREE| $y$ \\
  \verb|Return| $a$ & \verb|RETURN| $a$ \\
  \verb|Returnv| & \verb|RETURNV| \\
  \verb|Calllfunl| $y\ f\ [a]$ & $y$ \verb|::==| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfun| $x\ f\ [a]$ & $x$ \verb|::=| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfunv| $f\ [a]$ & \verb|CALL| $f$ \verb|(| $[a]$ \verb|)| \\
  \hline
\end{tabular}

\caption{Abstract and concrete syntax equivalence}
\label{tab:concrete_syntax}
\end{table}


\subsection{Functions}\label{subsection:functions_commands}

In Chloe we have both functions that return values and those which dont have a return value.
For functions that do return a value we needed to figure out what to do with it.
We decided that the return value of every function should be assigned to a dummy variable or to a destination in a memory cell whenever a function was returning from a call.
We won't go into details explaining this design decision now but rather delay it until section~\ref{section:states} where we will be able to explain the reasoning behind this in a better way.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record fun_decl =
    name :: fname
    params :: vname list
    locals :: vname list
    body :: com

  valid_fun_decl :: fun_decl $\Rightarrow$ bool
  \end{lstlisting}

  \caption{Function definitions}
  \label{fig:fun_def}
\end{figure}

As we see in the definition in figure~\ref{fig:fun_def}, a function consists of a name, the formal parameters, the local variables and the body of the function, which is a, potentially big, command in the Chloe language.
We also define a predicate which checks whether a function declaration is valid or not.
A function declaration is considered valid if and only if the function parameters and the local variables have different names.

\subsection{Programs}\label{subsection:programs_commands}

A program in Chloe is conformed by a name, a list of global variables and a list of procedures as showed in figure~\ref{fig:prog_def}.
In that same figure we can see a definition that every valid program must comply with.

A program is considered valid if it complies with all the following conditions:

\begin{itemize}
  \item{The names for the global variables are different from one another.}
  \item{The names for the procedures in the program are different from one another.}
  \item{Every function declaration for every function in the program must be valid.}
  \item{The main procedure must be defined.}
  \item{None of the variable names or procedure names in the program must be a reserved keyword from C or a reserved keyword for testing.\footnote{Since we want to generate C code from the Chloe semantics we must guarantee that neither variable nor procedure names are any of the reserved C keywords or any of the reserved keywords used for testing variables.}}
  \item{The global variables and the procedure names in a program can't be the same.}
\end{itemize}



\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record program =
    name :: string
    globals :: vname list
    procs :: fun_decl list

  reserved_keywords =
    [''auto'', ''break'', ''case'', ''char'', ''const'', ''continue'',
     ''default'', ''do'', ''double'', ''else'', ''enum'', ''extern'',
     ''float'', ''for'', ''goto'', ''if'', ''inline'', ''int'', ''long'',
     ''register'', ''restrict'', ''return'', ''short'', ''signed'',
     ''sizeof'', ''static'', ''struct'', ''switch'', ''typedef'',
     ''union'', ''unsigned'', ''void'', ''volatile'', ''while'',
     ''_Bool'', ''_Complex'', ''_Imaginary'']

  test_keywords =
    [''num_tests'', ''passed'', ''failed'']

  definition valid_program :: program $\Rightarrow$ bool where
  valid_program p $\equiv$
      distinct (program.globals p)
    $\bigwedge$ distinct (map fun_decl.name (program.procs p))
    $\bigwedge$ ($\forall$ fd $\in$ set (progarm.procs p). valid_fun_decl fd)
    $\bigwedge$ ( let
         pt = proc_table_of p
       in
         ''main'' $\in$ dom pt
         $\bigwedge$ fun_decl.params (the (pt ''main'')) = [])
   $\bigwedge$ ( let
         prog_vars = set ((program.globals p) @
           collect_locals (program.procs p));
         proc_names = set (map (fun_decl.name) (program.procs p))
       in
         ($\forall$ name $\in$ prog_vars.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ name $\in$ proc_names.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ fname $\in$ proc_names.
           ($\forall$ vname $\in$ set (program.globals p). fname $\neq$ vname)))
  \end{lstlisting}

  \caption{Program definitions}
  \label{fig:prog_def}
\end{figure}




\subsection{Semantics}\label{subsection:semantics_commands}

\section{Restrictions}\label{subsection:restrictions_commands}
Here we mention the architecture restrictions (64 bit architectures) this semantics assumes.
Not sure if int width should be explained here or before in the integer types.


\section{States}\label{section:states}

Don't forget to mention visible states again.

\subsection{Valuation}\label{subsection:valuation}
\subsection{Stack}\label{subsection:stack}
\subsection{Procedure Table}\label{subsection:procedure_table}

\section{Small Step Semantics}\label{section:small_step}

\subsection{CFG}\label{subsection:cfg}
\subsection{Small Step semantics rules}\label{subsection:rules_small_step}

\section{Interpreter}\label{section:interpreter}

\subsection{Single step}\label{subsection:single_step}
\subsection{Execution and Interpretation}\label{subsection:exec_interp}
\subsection{Correctness}\label{subsection:correctness}
