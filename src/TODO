TODO:
  Extend to state monad. Let the state be memory, 
  and later the whole program state. 
  
  Try to reflect basic C commands also in state monad, i.e., 
  do a "shallowly embedded C". This may, first, make the semantics
  cleaner by a better separation of syntax and meaning. Second, it serves
  as an intermediate layer for proving and translation. A 
  translation can be split up to first generate into the shallow embedding,
  and then to the deep embedding. This may result in better modularity.


DONE:
  2016-2: Structs, type-checker, and type-preservation proof in place.
    Roughly, program evaluation is inside an error monad, 
    that distinguishes between several classes of errors. 
    The type preservation proof states that a program that passed the 
    type-checker will never throw static errors. 
    These errors are generated by the semantics if it finds wrong dynamic 
    types for operations, or structural errors, like missing variables or
    empty stack-frame during execution.

